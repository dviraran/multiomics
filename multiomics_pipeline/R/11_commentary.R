# =============================================================================
# Figure Commentary Generation for Multi-Omics Integration Pipeline
# =============================================================================
# This module generates AI-powered or data-driven commentary for pipeline figures
# Supports Claude Vision API, OpenAI GPT-4 Vision API, or deterministic fallback

#' Build a table of all figures generated by the pipeline with metadata
#'
#' @param mae_data Multi-assay experiment data
#' @param integration_results Results from integration methods (MOFA, DIABLO, SNF)
#' @param concordance_results Cross-omics concordance results
#' @param enrichment_results Pathway enrichment results
#' @param config Pipeline configuration
#' @return A tibble with figure paths and metadata
build_figures_table <- function(mae_data,
                                 integration_results,
                                 concordance_results,
                                 enrichment_results,
                                 config) {

  log_message("Building figures metadata table...")

  output_dir <- config$output$output_dir
  plots_dir <- file.path(output_dir, "plots")
  omics_present <- names(mae_data$harmonized_omics)


  figures <- list()

  # ---------------------------------------------------------------------------

  # MOFA2 Figures
  # ---------------------------------------------------------------------------
  if (!is.null(integration_results$mofa)) {
    # Variance heatmap
    fig_path <- file.path(plots_dir, "mofa_variance_heatmap.png")
    if (file.exists(fig_path)) {
      figures[["mofa_variance_heatmap"]] <- list(
        figure_id = "mofa_variance_heatmap",
        file_path = fig_path,
        plot_type = "heatmap",
        title = "MOFA2 Variance Explained Heatmap",
        description = "Heatmap showing variance explained by each MOFA factor in each omics view",
        section = "MOFA2 Integration",
        x_axis = "Factor",
        y_axis = "Omics View"
      )
    }

    # Factor scatter plot
    fig_path <- file.path(plots_dir, "mofa_factors_1_2.png")
    if (file.exists(fig_path)) {
      figures[["mofa_factors_1_2"]] <- list(
        figure_id = "mofa_factors_1_2",
        file_path = fig_path,
        plot_type = "scatter",
        title = "MOFA2 Factor Plot (Factor 1 vs 2)",
        description = "Scatter plot of samples in MOFA factor space colored by condition",
        section = "MOFA2 Integration",
        x_axis = "Factor 1",
        y_axis = "Factor 2"
      )
    }

    # Factor weights
    for (omic in omics_present) {
      fig_path <- file.path(plots_dir, paste0("mofa_weights_", omic, ".png"))
      if (file.exists(fig_path)) {
        figures[[paste0("mofa_weights_", omic)]] <- list(
          figure_id = paste0("mofa_weights_", omic),
          file_path = fig_path,
          plot_type = "bar",
          title = paste0("MOFA2 Feature Weights - ", tools::toTitleCase(omic)),
          description = paste0("Top contributing features to MOFA factors from ", omic),
          section = "MOFA2 Integration",
          x_axis = "Feature",
          y_axis = "Weight"
        )
      }
    }
  }

  # ---------------------------------------------------------------------------
  # DIABLO Figures
  # ---------------------------------------------------------------------------
  if (!is.null(integration_results$diablo)) {
    # Sample plot
    fig_path <- file.path(plots_dir, "diablo_sample_plot_comp1_2.png")
    if (file.exists(fig_path)) {
      figures[["diablo_sample_plot"]] <- list(
        figure_id = "diablo_sample_plot",
        file_path = fig_path,
        plot_type = "scatter",
        title = "DIABLO Sample Plot",
        description = "Samples in DIABLO component space, showing separation by condition",
        section = "DIABLO Integration",
        x_axis = "Component 1",
        y_axis = "Component 2"
      )
    }

    # Loading plots
    for (omic in omics_present) {
      fig_path <- file.path(plots_dir, paste0("diablo_loadings_", omic, ".png"))
      if (file.exists(fig_path)) {
        figures[[paste0("diablo_loadings_", omic)]] <- list(
          figure_id = paste0("diablo_loadings_", omic),
          file_path = fig_path,
          plot_type = "bar",
          title = paste0("DIABLO Loadings - ", tools::toTitleCase(omic)),
          description = paste0("Feature loadings from DIABLO for ", omic),
          section = "DIABLO Integration",
          x_axis = "Feature",
          y_axis = "Loading"
        )
      }
    }

    # Circos plot
    fig_path <- file.path(plots_dir, "diablo_circos.png")
    if (file.exists(fig_path)) {
      figures[["diablo_circos"]] <- list(
        figure_id = "diablo_circos",
        file_path = fig_path,
        plot_type = "circos",
        title = "DIABLO Circos Plot",
        description = "Circular plot showing correlations between selected features across omics",
        section = "DIABLO Integration",
        x_axis = "NA",
        y_axis = "NA"
      )
    }

    # CV error rate plot
    fig_path <- file.path(plots_dir, "diablo_cv_error.png")
    if (file.exists(fig_path)) {
      figures[["diablo_cv_error"]] <- list(
        figure_id = "diablo_cv_error",
        file_path = fig_path,
        plot_type = "line",
        title = "DIABLO Cross-Validation Error",
        description = "Classification error rate across CV folds and components",
        section = "DIABLO Integration",
        x_axis = "Component",
        y_axis = "Error Rate"
      )
    }
  }

  # ---------------------------------------------------------------------------
  # SNF Figures
  # ---------------------------------------------------------------------------
  if (!is.null(integration_results$snf)) {
    # MDS plot
    fig_path <- file.path(plots_dir, "snf_mds.png")
    if (file.exists(fig_path)) {
      figures[["snf_mds"]] <- list(
        figure_id = "snf_mds",
        file_path = fig_path,
        plot_type = "scatter",
        title = "SNF MDS Plot",
        description = "MDS visualization of fused similarity network, colored by cluster",
        section = "SNF Integration",
        x_axis = "MDS1",
        y_axis = "MDS2"
      )
    }

    # Fused network heatmap
    fig_path <- file.path(plots_dir, "snf_heatmap.png")
    if (file.exists(fig_path)) {
      figures[["snf_heatmap"]] <- list(
        figure_id = "snf_heatmap",
        file_path = fig_path,
        plot_type = "heatmap",
        title = "SNF Fused Network Heatmap",
        description = "Heatmap of the fused similarity network from SNF",
        section = "SNF Integration",
        x_axis = "Sample",
        y_axis = "Sample"
      )
    }
  }

  # ---------------------------------------------------------------------------
  # Concordance Figures
  # ---------------------------------------------------------------------------
  if (!is.null(concordance_results$rna_protein)) {
    # Correlation distribution
    fig_path <- file.path(plots_dir, "rna_protein_concordance.png")
    if (file.exists(fig_path)) {
      figures[["rna_protein_concordance"]] <- list(
        figure_id = "rna_protein_concordance",
        file_path = fig_path,
        plot_type = "histogram",
        title = "RNA-Protein Concordance Distribution",
        description = "Distribution of correlation coefficients between RNA and protein expression",
        section = "Cross-Omics Concordance",
        x_axis = "Pearson Correlation",
        y_axis = "Count"
      )
    }

    # DE scatter plot
    fig_path <- file.path(plots_dir, "rna_protein_de_scatter.png")
    if (file.exists(fig_path)) {
      figures[["rna_protein_de_scatter"]] <- list(
        figure_id = "rna_protein_de_scatter",
        file_path = fig_path,
        plot_type = "scatter",
        title = "RNA vs Protein Fold Change",
        description = "Scatter plot comparing differential expression fold changes between RNA and protein",
        section = "Cross-Omics Concordance",
        x_axis = "RNA Log2 Fold Change",
        y_axis = "Protein Log2 Fold Change"
      )
    }
  }

  # ---------------------------------------------------------------------------
  # Enrichment Figures
  # ---------------------------------------------------------------------------
  for (omic in omics_present) {
    # ORA dotplot
    fig_path <- file.path(plots_dir, paste0(omic, "_ora_dotplot.png"))
    if (file.exists(fig_path)) {
      figures[[paste0("ora_", omic)]] <- list(
        figure_id = paste0("ora_", omic),
        file_path = fig_path,
        plot_type = "dotplot",
        title = paste0("ORA Enrichment - ", tools::toTitleCase(omic)),
        description = paste0("Over-representation analysis results for ", omic),
        section = "Pathway Enrichment",
        x_axis = "-Log10(Adjusted P-value)",
        y_axis = "Pathway"
      )
    }
  }

  # Combined enrichment
  fig_path <- file.path(plots_dir, "combined_enrichment.png")
  if (file.exists(fig_path)) {
    figures[["combined_enrichment"]] <- list(
      figure_id = "combined_enrichment",
      file_path = fig_path,
      plot_type = "dotplot",
      title = "Combined Multi-Omics Enrichment",
      description = "Pathways enriched across multiple omics layers",
      section = "Pathway Enrichment",
      x_axis = "-Log10(Combined P-value)",
      y_axis = "Pathway"
    )
  }

  # Convert to tibble
  if (length(figures) == 0) {
    log_message("No figures found to generate commentary for")
    return(tibble(
      figure_id = character(),
      file_path = character(),
      plot_type = character(),
      title = character(),
      description = character(),
      section = character(),
      x_axis = character(),
      y_axis = character()
    ))
  }

  figures_tbl <- bind_rows(lapply(figures, as_tibble))

  log_message("Found ", nrow(figures_tbl), " figures for commentary")

  return(figures_tbl)
}


#' Generate commentary for all figures
#'
#' @param figures_tbl Table of figures with metadata
#' @param config Pipeline configuration
#' @param mae_data Multi-assay experiment data
#' @param integration_results Integration results
#' @param concordance_results Concordance results
#' @param output_dir Directory to save commentary JSON files
#' @return A tibble with figure IDs and commentary
generate_all_commentary <- function(figures_tbl,
                                     config,
                                     mae_data,
                                     integration_results,
                                     concordance_results,
                                     output_dir) {

  # Check if commentary is enabled
  commentary_enabled <- config$commentary$enabled %||% FALSE

  if (!commentary_enabled) {
    log_message("Commentary generation is disabled in config")
    return(tibble(
      figure_id = character(),
      commentary_json = character(),
      backend = character()
    ))
  }

  log_message("Generating figure commentary...")

  # Create output directory
  if (!dir.exists(output_dir)) {
    dir.create(output_dir, recursive = TRUE)
  }

  backend <- config$commentary$backend %||% "none"
  log_message("Using commentary backend: ", backend)

  # Generate commentary for each figure
  commentary_list <- list()

  for (i in seq_len(nrow(figures_tbl))) {
    fig <- figures_tbl[i, ]
    figure_id <- fig$figure_id

    log_message("Generating commentary for: ", figure_id)

    # Build context for this figure
    context <- build_figure_context(fig, config, mae_data, integration_results, concordance_results)

    # Generate commentary based on backend
    commentary <- tryCatch({
      if (backend == "claude") {
        run_claude_commentary(fig, context, config, output_dir)
      } else if (backend == "openai") {
        run_openai_commentary(fig, context, config, output_dir)
      } else {
        # Data-driven fallback
        generate_fallback_commentary(fig, context, mae_data, integration_results, concordance_results, config)
      }
    }, error = function(e) {
      log_message("Error generating commentary for ", figure_id, ": ", e$message)
      create_placeholder_commentary(figure_id, e$message)
    })

    # Save individual JSON
    json_path <- file.path(output_dir, paste0(figure_id, ".json"))
    write(jsonlite::toJSON(commentary, auto_unbox = TRUE, pretty = TRUE), json_path)

    commentary_list[[figure_id]] <- list(
      figure_id = figure_id,
      commentary_json = jsonlite::toJSON(commentary, auto_unbox = TRUE),
      backend = backend
    )
  }

  # Combine into tibble
  commentary_tbl <- bind_rows(commentary_list)

  # Save combined CSV
  combined_path <- file.path(output_dir, "all_commentary.csv")
  write_csv(commentary_tbl, combined_path)

  # Save combined JSON
  all_commentary <- lapply(commentary_list, function(x) {
    jsonlite::fromJSON(x$commentary_json)
  })
  write(jsonlite::toJSON(all_commentary, auto_unbox = TRUE, pretty = TRUE),
        file.path(output_dir, "all_commentary.json"))

  log_message("Commentary saved to: ", output_dir)

  return(commentary_tbl)
}


#' Build context for a specific figure
#'
#' @param fig Figure row from figures_tbl
#' @param config Configuration
#' @param mae_data MAE data
#' @param integration_results Integration results
#' @param concordance_results Concordance results
#' @return List with context information
build_figure_context <- function(fig, config, mae_data, integration_results, concordance_results) {
  context <- list(
    plot_type = fig$plot_type,
    title = fig$title,
    description = fig$description,
    section = fig$section,
    x_axis = fig$x_axis,
    y_axis = fig$y_axis,
    organism = config$global$organism,
    n_samples = length(mae_data$common_samples),
    omics_present = paste(names(mae_data$harmonized_omics), collapse = ", "),
    condition_col = config$design$condition_column,
    design_formula = config$design$design_formula
  )

  figure_id <- fig$figure_id

  # Add MOFA-specific context
  if (grepl("^mofa_", figure_id) && !is.null(integration_results$mofa)) {
    mofa <- integration_results$mofa
    if (!is.null(mofa$variance_explained)) {
      context$mofa_total_variance <- sum(mofa$variance_explained$total)
      context$mofa_n_factors <- ncol(mofa$variance_explained)
    }
  }

  # Add DIABLO-specific context
  if (grepl("^diablo_", figure_id) && !is.null(integration_results$diablo)) {
    diablo <- integration_results$diablo
    if (!is.null(diablo$cv_error)) {
      context$diablo_cv_error <- min(diablo$cv_error)
    }
    if (!is.null(diablo$selected_features)) {
      context$diablo_n_features <- sum(sapply(diablo$selected_features, length))
    }
  }

  # Add SNF-specific context
  if (grepl("^snf_", figure_id) && !is.null(integration_results$snf)) {
    snf <- integration_results$snf
    if (!is.null(snf$nmi)) {
      context$snf_nmi <- snf$nmi
    }
    if (!is.null(snf$n_clusters)) {
      context$snf_n_clusters <- snf$n_clusters
    }
  }

  # Add concordance-specific context
  if (grepl("concordance|de_scatter", figure_id) && !is.null(concordance_results$rna_protein)) {
    rp <- concordance_results$rna_protein
    if (!is.null(rp$summary)) {
      context$concordance_mean_cor <- rp$summary$mean_cor
      context$concordance_n_genes <- rp$summary$n_genes
      context$concordance_pct_positive <- rp$summary$pct_positive
    }
  }

  return(context)
}


#' Run Claude Vision API for commentary
run_claude_commentary <- function(fig, context, config, output_dir) {
  # Write context to temp file
  context_file <- tempfile(fileext = ".json")
  write(jsonlite::toJSON(context, auto_unbox = TRUE), context_file)

  out_file <- file.path(output_dir, paste0(fig$figure_id, "_claude.json"))

  # Find the Python script
  script_path <- "scripts/figure_commentary_claude.py"
  if (!file.exists(script_path)) {
    stop("Claude commentary script not found: ", script_path)
  }

  # Build command
  model <- config$commentary$claude_model %||% "claude-sonnet-4-20250514"
  max_tokens <- config$commentary$max_tokens %||% 1500
  max_retries <- config$commentary$max_retries %||% 2

  cmd <- sprintf(
    "python3 '%s' --image '%s' --figure_id '%s' --context_json '%s' --out_json '%s' --model '%s' --max_tokens %d --max_retries %d",
    script_path, fig$file_path, fig$figure_id, context_file, out_file, model, max_tokens, max_retries
  )

  result <- system(cmd, intern = TRUE, ignore.stderr = FALSE)

  # Read and return the generated commentary
  if (file.exists(out_file)) {
    commentary <- jsonlite::fromJSON(out_file)
  } else {
    stop("Claude commentary script did not produce output")
  }

  # Cleanup
  unlink(context_file)

  return(commentary)
}


#' Run OpenAI Vision API for commentary
run_openai_commentary <- function(fig, context, config, output_dir) {
  # Write context to temp file
  context_file <- tempfile(fileext = ".json")
  write(jsonlite::toJSON(context, auto_unbox = TRUE), context_file)

  out_file <- file.path(output_dir, paste0(fig$figure_id, "_openai.json"))

  # Find the Python script
  script_path <- "scripts/figure_commentary_openai.py"
  if (!file.exists(script_path)) {
    stop("OpenAI commentary script not found: ", script_path)
  }

  # Build command
  model <- config$commentary$openai_model %||% "gpt-4o"
  max_tokens <- config$commentary$max_tokens %||% 1500
  max_retries <- config$commentary$max_retries %||% 2

  cmd <- sprintf(
    "python3 '%s' --image '%s' --figure_id '%s' --context_json '%s' --out_json '%s' --model '%s' --max_tokens %d --max_retries %d",
    script_path, fig$file_path, fig$figure_id, context_file, out_file, model, max_tokens, max_retries
  )

  result <- system(cmd, intern = TRUE, ignore.stderr = FALSE)

  # Read and return the generated commentary
  if (file.exists(out_file)) {
    commentary <- jsonlite::fromJSON(out_file)
  } else {
    stop("OpenAI commentary script did not produce output")
  }

  # Cleanup
  unlink(context_file)

  return(commentary)
}


#' Create placeholder commentary on error
create_placeholder_commentary <- function(figure_id, error_message) {
  list(
    figure_id = figure_id,
    title = "Commentary Generation Failed",
    what_is_this = "Unable to generate automated commentary for this figure.",
    observations = list(),
    issues_checks = list(),
    next_steps = list(),
    confidence = "none",
    limitations = paste("Error:", error_message)
  )
}


#' Generate fallback data-driven commentary (no LLM)
generate_fallback_commentary <- function(fig, context, mae_data, integration_results, concordance_results, config) {
  figure_id <- fig$figure_id

  # Route to specific fallback function
  if (grepl("^mofa_variance", figure_id)) {
    return(fallback_mofa_variance(fig, context, integration_results))
  } else if (grepl("^mofa_factors", figure_id)) {
    return(fallback_mofa_factors(fig, context, integration_results))
  } else if (grepl("^mofa_weights", figure_id)) {
    return(fallback_mofa_weights(fig, context, integration_results))
  } else if (grepl("^diablo_sample", figure_id)) {
    return(fallback_diablo_sample(fig, context, integration_results))
  } else if (grepl("^diablo_loadings", figure_id)) {
    return(fallback_diablo_loadings(fig, context, integration_results))
  } else if (grepl("^diablo_circos", figure_id)) {
    return(fallback_diablo_circos(fig, context, integration_results))
  } else if (grepl("^diablo_cv", figure_id)) {
    return(fallback_diablo_cv(fig, context, integration_results))
  } else if (grepl("^snf_mds", figure_id)) {
    return(fallback_snf_mds(fig, context, integration_results))
  } else if (grepl("^snf_heatmap", figure_id)) {
    return(fallback_snf_heatmap(fig, context, integration_results))
  } else if (grepl("concordance", figure_id)) {
    return(fallback_concordance(fig, context, concordance_results))
  } else if (grepl("de_scatter", figure_id)) {
    return(fallback_de_scatter(fig, context, concordance_results))
  } else if (grepl("^ora_|^combined_enrichment", figure_id)) {
    return(fallback_enrichment(fig, context))
  } else {
    return(fallback_generic(fig, context))
  }
}


# =============================================================================
# Fallback Commentary Functions
# =============================================================================

fallback_mofa_variance <- function(fig, context, integration_results) {
  mofa <- integration_results$mofa

  observations <- list(
    "This heatmap displays the percentage of variance explained by each MOFA factor in each omics view.",
    paste0("The analysis included ", context$omics_present, " omics layers.")
  )

  if (!is.null(mofa$variance_explained)) {
    total_var <- sum(mofa$variance_explained$total)
    observations <- c(observations,
      paste0("Factors collectively explain approximately ", round(total_var, 1), "% of total variance.")
    )
  }

  list(
    figure_id = fig$figure_id,
    title = fig$title,
    what_is_this = "MOFA2 variance explained heatmap showing how much variance each latent factor captures from each omics view. Factors capturing variance from multiple views represent shared biological signal.",
    observations = observations,
    issues_checks = list(
      "Check if some factors are dominated by a single omics view (may indicate technical variation)",
      "Factors explaining very little variance may be noise and could be excluded"
    ),
    next_steps = list(
      "Examine factor weights to identify key features",
      "Test factor associations with clinical variables",
      "Focus on factors with multi-view contributions for biological interpretation"
    ),
    confidence = "medium",
    limitations = "Data-driven commentary based on summary statistics"
  )
}


fallback_mofa_factors <- function(fig, context, integration_results) {
  mofa <- integration_results$mofa

  observations <- list(
    "This scatter plot shows samples positioned according to their MOFA factor values.",
    paste0("Samples are colored by ", context$condition_col, "."),
    paste0("Analysis includes ", context$n_samples, " samples from ", context$omics_present, ".")
  )

  list(
    figure_id = fig$figure_id,
    title = fig$title,
    what_is_this = "MOFA2 factor plot showing samples in the latent factor space. Samples that cluster together share similar multi-omics profiles. Factor 1 typically captures the most variance.",
    observations = observations,
    issues_checks = list(
      "Check if sample groups separate along factor axes",
      "Look for outlier samples that don't cluster with their group",
      "Consider if separation is driven by biological signal or batch effects"
    ),
    next_steps = list(
      "Identify which factors correlate with condition",
      "Examine factor loadings to understand what drives separation",
      "Test factors for association with other clinical covariates"
    ),
    confidence = "medium",
    limitations = "Data-driven commentary; visual patterns require manual inspection"
  )
}


fallback_mofa_weights <- function(fig, context, integration_results) {
  omic <- sub("mofa_weights_", "", fig$figure_id)

  list(
    figure_id = fig$figure_id,
    title = fig$title,
    what_is_this = paste0("MOFA2 feature weights showing the contribution of individual ", omic, " features to each latent factor. High absolute weights indicate features that strongly define the factor."),
    observations = list(
      paste0("This plot shows top contributing features from ", omic, " to MOFA factors."),
      "Features with high positive or negative weights drive the factor pattern.",
      "Features with weights near zero contribute little to that factor."
    ),
    issues_checks = list(
      "Verify top features are biologically meaningful",
      "Check if housekeeping or technical features dominate (potential QC issue)"
    ),
    next_steps = list(
      "Perform pathway enrichment on high-weight features",
      "Cross-reference top features with differential analysis results",
      "Investigate features appearing in multiple important factors"
    ),
    confidence = "medium",
    limitations = "Data-driven commentary based on figure metadata"
  )
}


fallback_diablo_sample <- function(fig, context, integration_results) {
  diablo <- integration_results$diablo

  observations <- list(
    "This plot shows samples in DIABLO component space, integrating all omics views.",
    paste0("Samples are colored by ", context$condition_col, "."),
    "DIABLO is a supervised method that maximizes separation between groups."
  )

  if (!is.null(context$diablo_cv_error)) {
    observations <- c(observations,
      paste0("Cross-validation error rate: ", round(context$diablo_cv_error * 100, 1), "%")
    )
  }

  list(
    figure_id = fig$figure_id,
    title = fig$title,
    what_is_this = "DIABLO sample plot showing multi-omics integration results. Unlike PCA, DIABLO explicitly optimizes for group separation using features from all omics layers.",
    observations = observations,
    issues_checks = list(
      "Good separation suggests reliable multi-omics biomarker panel",
      "Overlapping groups may indicate weak signal or need for more samples",
      "Check for overfitting by examining CV error rates"
    ),
    next_steps = list(
      "Review selected features from each omics layer",
      "Examine the circos plot for cross-omics correlations",
      "Validate key features in an independent cohort"
    ),
    confidence = "medium",
    limitations = "Data-driven commentary; classification performance requires CV metrics"
  )
}


fallback_diablo_loadings <- function(fig, context, integration_results) {
  omic <- sub("diablo_loadings_", "", fig$figure_id)

  list(
    figure_id = fig$figure_id,
    title = fig$title,
    what_is_this = paste0("DIABLO loading plot showing selected ", omic, " features and their contribution to discriminant components. These are the features most important for multi-omics classification."),
    observations = list(
      paste0("Features from ", omic, " selected by DIABLO for optimal classification."),
      "Loading magnitude indicates feature importance for group discrimination.",
      "Features are selected through sparse regularization (LASSO-like)."
    ),
    issues_checks = list(
      "Verify selected features are biologically interpretable",
      "Check if key known markers are included in selection"
    ),
    next_steps = list(
      "Validate selected features with univariate tests",
      "Perform pathway analysis on selected feature set",
      "Consider these features for biomarker panel development"
    ),
    confidence = "medium",
    limitations = "Data-driven commentary based on figure metadata"
  )
}


fallback_diablo_circos <- function(fig, context, integration_results) {
  list(
    figure_id = fig$figure_id,
    title = fig$title,
    what_is_this = "DIABLO circos plot visualizing correlations between selected features across different omics layers. Lines connect features that co-vary, revealing cross-omics regulatory relationships.",
    observations = list(
      "Each arc represents a different omics layer.",
      "Lines connect features with strong correlations across omics.",
      "Dense connections suggest coordinated multi-omics patterns."
    ),
    issues_checks = list(
      "Look for biologically meaningful cross-omics connections",
      "Sparse connections may indicate independent omics patterns"
    ),
    next_steps = list(
      "Investigate the most connected features (hub features)",
      "Map connections to known biological pathways",
      "Consider connected feature pairs for mechanistic studies"
    ),
    confidence = "medium",
    limitations = "Data-driven commentary; connection details require table inspection"
  )
}


fallback_diablo_cv <- function(fig, context, integration_results) {
  diablo <- integration_results$diablo

  observations <- list(
    "This plot shows classification error rate across cross-validation folds.",
    "Lower error rates indicate better classification performance.",
    "The optimal number of components balances accuracy and model complexity."
  )

  if (!is.null(context$diablo_cv_error)) {
    observations <- c(observations,
      paste0("Minimum CV error: ", round(context$diablo_cv_error * 100, 1), "%")
    )
  }

  list(
    figure_id = fig$figure_id,
    title = fig$title,
    what_is_this = "DIABLO cross-validation error plot showing classification performance. This assesses how well the multi-omics signature generalizes to unseen samples.",
    observations = observations,
    issues_checks = list(
      "Error rate > 30% suggests weak discriminative signal",
      "Large variance across folds may indicate sample heterogeneity",
      "Overfitting suspected if training error << CV error"
    ),
    next_steps = list(
      "Select optimal component number based on error plateau",
      "Consider external validation on independent samples",
      "If error is high, revisit feature selection strategy"
    ),
    confidence = "medium",
    limitations = "Data-driven commentary based on figure metadata"
  )
}


fallback_snf_mds <- function(fig, context, integration_results) {
  snf <- integration_results$snf

  observations <- list(
    "This MDS plot visualizes the fused similarity network from SNF.",
    "Samples are colored by their SNF cluster assignment.",
    "SNF integrates omics by fusing sample similarity networks."
  )

  if (!is.null(context$snf_nmi)) {
    observations <- c(observations,
      paste0("NMI with condition: ", round(context$snf_nmi, 3))
    )
  }

  if (!is.null(context$snf_n_clusters)) {
    observations <- c(observations,
      paste0("Number of clusters: ", context$snf_n_clusters)
    )
  }

  list(
    figure_id = fig$figure_id,
    title = fig$title,
    what_is_this = "SNF MDS plot showing sample clustering based on fused multi-omics similarity. Unlike DIABLO, SNF is unsupervised and finds natural patient subgroups.",
    observations = observations,
    issues_checks = list(
      "Check if SNF clusters align with known condition groups",
      "Low NMI suggests clusters capture different structure than condition",
      "Look for potential novel patient subgroups"
    ),
    next_steps = list(
      "Compare SNF clusters with clinical outcomes",
      "Identify features that distinguish clusters",
      "Consider SNF for patient stratification"
    ),
    confidence = "medium",
    limitations = "Data-driven commentary; clustering quality depends on NMI and silhouette"
  )
}


fallback_snf_heatmap <- function(fig, context, integration_results) {
  list(
    figure_id = fig$figure_id,
    title = fig$title,
    what_is_this = "SNF fused network heatmap showing pairwise sample similarities after network fusion. High values (red) indicate similar multi-omics profiles. Block structure reveals sample clusters.",
    observations = list(
      "The heatmap shows the fused similarity matrix from SNF.",
      "Clear block structure indicates well-defined sample clusters.",
      "Off-diagonal patterns may reveal sub-structure within clusters."
    ),
    issues_checks = list(
      "Weak block structure suggests heterogeneous data",
      "Check if cluster blocks align with sample annotations"
    ),
    next_steps = list(
      "Examine cluster composition relative to condition",
      "Identify samples that bridge clusters",
      "Consider alternative number of clusters if structure is unclear"
    ),
    confidence = "medium",
    limitations = "Data-driven commentary based on figure metadata"
  )
}


fallback_concordance <- function(fig, context, concordance_results) {
  rp <- concordance_results$rna_protein

  observations <- list(
    "This histogram shows the distribution of RNA-protein correlation coefficients.",
    "Positive correlations indicate concordant expression patterns."
  )

  if (!is.null(context$concordance_mean_cor)) {
    observations <- c(observations,
      paste0("Mean correlation: ", round(context$concordance_mean_cor, 3)),
      paste0("Number of genes compared: ", context$concordance_n_genes),
      paste0("Percentage with positive correlation: ", round(context$concordance_pct_positive, 1), "%")
    )
  }

  list(
    figure_id = fig$figure_id,
    title = fig$title,
    what_is_this = "RNA-protein concordance distribution showing how well mRNA expression predicts protein abundance. Positive correlations are expected, but post-transcriptional regulation causes deviations.",
    observations = observations,
    issues_checks = list(
      "Mean correlation < 0.3 suggests substantial post-transcriptional regulation",
      "Bimodal distribution may indicate two classes of genes",
      "Very low correlations could indicate sample mismatch or technical issues"
    ),
    next_steps = list(
      "Investigate genes with discordant RNA-protein patterns",
      "Check if discordant genes are enriched for specific functions",
      "Consider protein half-life and mRNA stability in interpretation"
    ),
    confidence = "medium",
    limitations = "Data-driven commentary based on summary statistics"
  )
}


fallback_de_scatter <- function(fig, context, concordance_results) {
  observations <- list(
    "This scatter plot compares log2 fold changes between RNA and protein.",
    "Points on the diagonal show concordant direction of change.",
    "Off-diagonal points indicate discordant regulation."
  )

  list(
    figure_id = fig$figure_id,
    title = fig$title,
    what_is_this = "RNA vs protein fold change scatter plot comparing differential expression results. Concordant features change in the same direction at both levels, suggesting transcriptional control.",
    observations = observations,
    issues_checks = list(
      "Low correlation suggests post-transcriptional regulation dominates",
      "Quadrant analysis: concordant (Q1, Q3) vs discordant (Q2, Q4)",
      "Outliers may represent interesting regulatory cases"
    ),
    next_steps = list(
      "Focus on concordant features for reliable biomarkers",
      "Investigate discordant features for post-transcriptional mechanisms",
      "Perform pathway analysis on concordant vs discordant sets"
    ),
    confidence = "medium",
    limitations = "Data-driven commentary; requires visual inspection for patterns"
  )
}


fallback_enrichment <- function(fig, context) {
  omic <- sub("^ora_", "", fig$figure_id)

  if (fig$figure_id == "combined_enrichment") {
    return(list(
      figure_id = fig$figure_id,
      title = fig$title,
      what_is_this = "Combined multi-omics enrichment showing pathways significant across multiple omics layers. These represent convergent biological signals supported by independent molecular evidence.",
      observations = list(
        "Pathways enriched in multiple omics provide stronger biological evidence.",
        "Combined p-values integrate evidence across omics layers.",
        "Top pathways represent consensus biological signals."
      ),
      issues_checks = list(
        "Check overlap between pathway gene sets and measured features",
        "Pathways enriched in only one omics may still be important"
      ),
      next_steps = list(
        "Prioritize pathways with multi-omics support for follow-up",
        "Examine individual omics contributions to top pathways",
        "Integrate pathway findings with integration method results"
      ),
      confidence = "medium",
      limitations = "Data-driven commentary based on figure metadata"
    ))
  }

  list(
    figure_id = fig$figure_id,
    title = fig$title,
    what_is_this = paste0("Over-representation analysis (ORA) results for ", omic, " showing enriched biological pathways. Dot size indicates gene count, position shows significance."),
    observations = list(
      paste0("Enrichment analysis for ", omic, " differential features."),
      "Pathways are ranked by adjusted p-value significance.",
      "Larger dots indicate more features in the pathway."
    ),
    issues_checks = list(
      "Check for redundant pathway terms (GO hierarchy)",
      "Very broad terms may be less informative than specific ones"
    ),
    next_steps = list(
      "Compare enriched pathways across omics layers",
      "Focus on specific, interpretable pathways",
      "Examine leading-edge genes in top pathways"
    ),
    confidence = "medium",
    limitations = "Data-driven commentary based on figure metadata"
  )
}


fallback_generic <- function(fig, context) {
  list(
    figure_id = fig$figure_id,
    title = fig$title,
    what_is_this = fig$description,
    observations = list(
      paste0("This is a ", fig$plot_type, " plot from the ", fig$section, " section."),
      paste0("Analysis includes ", context$n_samples, " samples and ", context$omics_present, " omics.")
    ),
    issues_checks = list(
      "Review the figure for expected patterns",
      "Check consistency with other analysis results"
    ),
    next_steps = list(
      "Cross-reference with related figures and tables",
      "Consider statistical significance of observed patterns"
    ),
    confidence = "low",
    limitations = "Generic data-driven commentary"
  )
}


#' Get static explanation for a plot type
#'
#' @param plot_type The type of plot
#' @return A string with educational explanation
get_static_explanation <- function(plot_type) {
  explanations <- list(
    "mofa_variance_heatmap" = "MOFA2 (Multi-Omics Factor Analysis v2) identifies latent factors that capture shared variation across multiple omics. The variance explained heatmap shows how much each factor contributes to each omics layer, helping identify factors driven by shared vs. omics-specific signals.",
    "mofa_factors" = "MOFA factor plots show samples in reduced dimension space defined by latent factors. Unlike PCA on concatenated data, MOFA learns factors that explicitly model the multi-view structure. Separation by condition suggests the factors capture biologically meaningful variation.",
    "diablo_sample" = "DIABLO (Data Integration Analysis for Biomarker discovery using Latent variable approaches for Omics studies) is a supervised multi-omics method. It finds sparse multi-omics signatures that maximize classification accuracy while selecting interpretable feature sets.",
    "diablo_circos" = "Circos plots visualize the correlation structure between features selected by DIABLO across omics layers. Strong connections between RNA-protein pairs may indicate transcriptional control, while connections to metabolites suggest functional relationships.",
    "snf_mds" = "Similarity Network Fusion (SNF) constructs patient similarity networks for each omics type and fuses them into a unified network. Unlike supervised methods, SNF discovers natural patient subgroups that may reveal novel disease subtypes.",
    "concordance" = "RNA-protein concordance measures how well mRNA abundance predicts protein levels. While positive correlation is expected, post-transcriptional regulation, protein stability, and technical factors typically result in correlations of 0.3-0.6 in well-matched samples.",
    "enrichment" = "Over-representation analysis (ORA) tests whether significantly changed features are enriched in biological pathways beyond what's expected by chance. Multi-omics enrichment combines evidence across layers for more robust pathway identification."
  )

  # Match by partial key
  for (key in names(explanations)) {
    if (grepl(key, plot_type, ignore.case = TRUE)) {
      return(explanations[[key]])
    }
  }

  return("This figure is part of the multi-omics integration analysis pipeline.")
}
